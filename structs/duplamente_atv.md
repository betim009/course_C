
# ExercÃ­cio 6 â€“ Lista Duplamente Encadeada em C

## ðŸ“Œ Entendendo o Enunciado

O exercÃ­cio pede para criar uma **Lista Duplamente Encadeada** que armazene **nÃºmeros inteiros** e tenha as seguintes funcionalidades:

| Letra | O que fazer                                    |
|------|-------------------------------------------------|
| a)   | Inserir na lista de forma ordenada (crescente)  |
| b)   | Remover um nÃºmero da lista de forma ordenada    |
| c)   | Inserir no inÃ­cio da lista                     |
| d)   | Remover no inÃ­cio da lista                     |
| e)   | Inserir no fim da lista                        |
| f)   | Remover no fim da lista                        |
| g)   | Pesquisar se um nÃºmero existe na lista          |

---

## âœ… Conceitos bÃ¡sicos antes de programar

### O que Ã© uma Lista Duplamente Encadeada?

- Cada nÃ³ tem **dois ponteiros**:
  - Um que aponta para o **prÃ³ximo nÃ³**
  - Um que aponta para o **nÃ³ anterior**

---

### Estrutura tÃ­pica do nÃ³:

```c
typedef struct No {
    int valor;
    struct No* ant;  // Anterior
    struct No* prox; // PrÃ³ximo
} No;
```

---

## âœ… DiferenÃ§as entre Lista Circular e Lista Duplamente Encadeada

| Item                          | Lista Circular Simples           | Lista Duplamente Encadeada Linear |
|-------------------------------|----------------------------------|----------------------------------|
| Ponteiros por nÃ³              | Apenas "prÃ³ximo"                 | "Anterior" e "PrÃ³ximo"           |
| Sentido de navegaÃ§Ã£o          | SÃ³ para frente                   | Frente e trÃ¡s                    |
| Fim da lista                  | Ãšltimo nÃ³ aponta pro inÃ­cio      | Ãšltimo nÃ³ aponta para NULL       |
| Tipo de ciclo                 | Tem ciclo (nunca acaba)          | NÃ£o tem ciclo (fim claro)        |

---

## âœ… Conceitos fundamentais para o aluno saber antes de codar:

| Conceito                      | Por que Ã© importante?                                |
|-------------------------------|------------------------------------------------------|
| Uso de `struct`               | Para criar o modelo do nÃ³                           |
| Ponteiros                     | Para conectar os nÃ³s                                |
| AlocaÃ§Ã£o dinÃ¢mica (malloc)    | Para criar nÃ³s em tempo de execuÃ§Ã£o                 |
| LiberaÃ§Ã£o de memÃ³ria (free)   | Para evitar vazamento de memÃ³ria                    |
| Controle de NULL              | Saber quando chegou no fim da lista                 |
| AtualizaÃ§Ã£o dupla de ponteiros| Porque cada nÃ³ tem dois ponteiros a serem ajustados |

---

## âœ… O que o aluno vai treinar com esse exercÃ­cio:

- Percorrer listas nos dois sentidos
- Atualizar mÃºltiplos ponteiros ao inserir ou remover
- Pensar com mais atenÃ§Ã£o nos casos de inÃ­cio e fim da lista
- Garantir que a lista nÃ£o quebre a sequÃªncia (nÃ£o deixar ponteiros soltos)

---

## âœ… ConclusÃ£o antes de partir para o cÃ³digo:

> Esse exercÃ­cio Ã© uma evoluÃ§Ã£o da lista simples.  
Agora, alÃ©m de controlar o "prÃ³ximo", o aluno precisa tambÃ©m controlar o "anterior".  
Isso dÃ¡ mais poder de navegaÃ§Ã£o, mas tambÃ©m exige mais cuidado ao alterar a lista.


-----


# Lista Duplamente Encadeada em C â€“ Estrutura do NÃ³ + criarNo()

## âœ… Estrutura do NÃ³

```c
typedef struct No {
    int valor;            // Valor guardado no nÃ³
    struct No* ant;       // Ponteiro para o nÃ³ anterior
    struct No* prox;      // Ponteiro para o prÃ³ximo nÃ³
} No;
```

### âœ… ExplicaÃ§Ã£o:

- `int valor;` â†’ Guarda o nÃºmero do nÃ³.
- `struct No* ant;` â†’ Aponta para o nÃ³ anterior.
- `struct No* prox;` â†’ Aponta para o prÃ³ximo nÃ³.

Essa estrutura permite andar **para frente e para trÃ¡s** na lista.

---

## âœ… FunÃ§Ã£o criarNo()

```c
No* criarNo(int valor) {
    No* novo = (No*) malloc(sizeof(No));  // Aloca memÃ³ria para o novo nÃ³
    novo->valor = valor;                  // Define o valor
    novo->ant = NULL;                     // Sem anterior no inÃ­cio
    novo->prox = NULL;                    // Sem prÃ³ximo no inÃ­cio
    return novo;                          // Retorna o ponteiro para o nÃ³ criado
}
```

### âœ… ExplicaÃ§Ã£o linha por linha:

- `malloc(sizeof(No))`: Reserva espaÃ§o na memÃ³ria para um nÃ³.
- `(No*)`: Faz o casting para ponteiro do tipo `No`.
- `novo->valor = valor;`: Coloca o nÃºmero informado dentro do campo `valor`.
- `novo->ant = NULL;`: Inicializa o ponteiro anterior como vazio.
- `novo->prox = NULL;`: Inicializa o ponteiro prÃ³ximo como vazio.
- `return novo;`: Devolve o nÃ³ pronto para quem chamou a funÃ§Ã£o.

---

## âœ… Exemplo de uso:

```c
No* primeiro = criarNo(10);
No* segundo = criarNo(20);
```
Aqui, criamos dois nÃ³s, mas **eles ainda nÃ£o estÃ£o ligados**. Vamos fazer isso nas funÃ§Ãµes de inserÃ§Ã£o (prÃ³xima etapa).

---


# Lista Duplamente Encadeada em C â€“ FunÃ§Ã£o inserirInicio()

## âœ… FunÃ§Ã£o inserirInicio

```c
No* inserirInicio(No* inicio, int valor) {
    No* novo = criarNo(valor);

    if (!inicio) {
        return novo;  // Se a lista estava vazia, o novo nÃ³ vira o inÃ­cio
    }

    novo->prox = inicio;        // Novo aponta para o antigo inÃ­cio
    inicio->ant = novo;         // O antigo inÃ­cio aponta de volta para o novo
    return novo;                // O novo agora Ã© o primeiro da lista
}
```

---

## âœ… ExplicaÃ§Ã£o detalhada:

- **ParÃ¢metros recebidos:**
  - `inicio`: ponteiro para o inÃ­cio da lista atual.
  - `valor`: nÃºmero que queremos adicionar.

- **Processo:**

| Linha                               | O que faz                                          |
|-------------------------------------|----------------------------------------------------|
| `No* novo = criarNo(valor);`        | Cria um novo nÃ³ com o valor informado              |
| `if (!inicio) return novo;`         | Se a lista estava vazia, o novo nÃ³ vira o inÃ­cio   |
| `novo->prox = inicio;`              | Faz o novo nÃ³ apontar para o antigo inÃ­cio         |
| `inicio->ant = novo;`               | Faz o antigo inÃ­cio apontar de volta para o novo   |
| `return novo;`                      | Retorna o novo inÃ­cio da lista                     |

---

## ðŸ§ª Exemplo prÃ¡tico de uso:

Lista antes:
```
[10] â†’ [20] â†’ [30]
```

Chamada:
```c
inicio = inserirInicio(inicio, 5);
```

Lista depois:
```
[5] â†’ [10] â†’ [20] â†’ [30]
```

Onde:
- O campo `ant` de `10` agora aponta para o `5`.
- O novo inÃ­cio Ã© o `5`.

---

## âœ… ConclusÃ£o:

Essa funÃ§Ã£o adiciona um novo valor no **comeÃ§o da lista duplamente encadeada**, cuidando de atualizar os dois ponteiros (anterior e prÃ³ximo).

---


# Lista Duplamente Encadeada em C â€“ FunÃ§Ã£o inserirFim()

## âœ… FunÃ§Ã£o inserirFim

```c
No* inserirFim(No* inicio, int valor) {
    No* novo = criarNo(valor);

    if (!inicio) {
        return novo;  // Se a lista estiver vazia, o novo nÃ³ vira o inÃ­cio
    }

    No* atual = inicio;
    while (atual->prox != NULL) {
        atual = atual->prox;  // AvanÃ§a atÃ© o Ãºltimo nÃ³
    }

    atual->prox = novo;   // O Ãºltimo nÃ³ aponta para o novo
    novo->ant = atual;    // O novo aponta de volta para o antigo Ãºltimo
    return inicio;        // O inÃ­cio da lista nÃ£o muda
}
```

---

## âœ… ExplicaÃ§Ã£o detalhada:

- **ParÃ¢metros recebidos:**
  - `inicio`: ponteiro para o inÃ­cio da lista atual.
  - `valor`: nÃºmero que queremos adicionar no final.

- **Processo:**

| Linha                               | O que faz                                          |
|-------------------------------------|----------------------------------------------------|
| `No* novo = criarNo(valor);`        | Cria o novo nÃ³ com o valor informado              |
| `if (!inicio) return novo;`         | Se a lista estiver vazia, o novo vira o inÃ­cio    |
| `No* atual = inicio;`               | ComeÃ§a a percorrer a lista                        |
| `while (atual->prox != NULL)`       | AvanÃ§a atÃ© o Ãºltimo nÃ³                            |
| `atual->prox = novo;`               | Faz o Ãºltimo nÃ³ apontar para o novo               |
| `novo->ant = atual;`                | Faz o novo nÃ³ apontar para o antigo Ãºltimo        |
| `return inicio;`                    | Retorna o inÃ­cio da lista                         |

---

## ðŸ§ª Exemplo prÃ¡tico de uso:

Lista antes:
```
[5] â†’ [10] â†’ [20]
```

Chamada:
```c
inicio = inserirFim(inicio, 30);
```

Lista depois:
```
[5] â†’ [10] â†’ [20] â†’ [30]
```

Onde:
- O campo `prox` de `20` agora aponta para `30`.
- O campo `ant` de `30` aponta para `20`.

---

## âœ… ConclusÃ£o:

Essa funÃ§Ã£o adiciona um novo valor **no final da lista**, mantendo o encadeamento duplo (frente e trÃ¡s).

---


# Lista Duplamente Encadeada em C â€“ FunÃ§Ã£o inserirOrdenado()

## âœ… FunÃ§Ã£o inserirOrdenado

```c
No* inserirOrdenado(No* inicio, int valor) {
    No* novo = criarNo(valor);

    if (!inicio || valor < inicio->valor) {
        novo->prox = inicio;
        if (inicio) {
            inicio->ant = novo;
        }
        return novo;
    }

    No* atual = inicio;
    while (atual->prox && atual->prox->valor < valor) {
        atual = atual->prox;
    }

    novo->prox = atual->prox;
    if (atual->prox) {
        atual->prox->ant = novo;
    }
    atual->prox = novo;
    novo->ant = atual;

    return inicio;
}
```

---

## âœ… ExplicaÃ§Ã£o detalhada:

| Linha                                | O que faz                                          |
|--------------------------------------|----------------------------------------------------|
| `No* novo = criarNo(valor);`         | Cria o novo nÃ³ com o valor informado              |
| `if (!inicio || valor < inicio->valor)` | Se a lista estiver vazia ou o valor for o menor, insere no inÃ­cio |
| `novo->prox = inicio;`               | Liga o novo nÃ³ ao antigo inÃ­cio                   |
| `if (inicio) inicio->ant = novo;`    | Atualiza o ponteiro anterior do antigo inÃ­cio     |
| Percorre com `atual`                 | Anda pela lista atÃ© achar a posiÃ§Ã£o certa         |
| LigaÃ§Ãµes finais                      | Ajusta os ponteiros do novo, do atual e do prÃ³ximo |
| `return inicio;`                     | Retorna o inÃ­cio da lista                         |

---

## ðŸ§ª Exemplo prÃ¡tico:

Lista antes:
```
[5] â†’ [10] â†’ [20]
```

Chamada:
```c
inicio = inserirOrdenado(inicio, 15);
```

Lista depois:
```
[5] â†’ [10] â†’ [15] â†’ [20]
```

---

## âœ… ConclusÃ£o:

Essa funÃ§Ã£o insere o novo valor na **posiÃ§Ã£o correta da lista**, mantendo a ordem crescente e atualizando os ponteiros `ant` e `prox` de forma segura.

---


# Lista Duplamente Encadeada em C â€“ FunÃ§Ã£o removerInicio()

## âœ… FunÃ§Ã£o removerInicio

```c
No* removerInicio(No* inicio) {
    if (!inicio) return NULL;  // Lista vazia

    No* temp = inicio;         // Guarda o primeiro nÃ³ para liberar depois
    inicio = inicio->prox;     // O novo inÃ­cio Ã© o prÃ³ximo da lista

    if (inicio) {
        inicio->ant = NULL;    // Se ainda houver nÃ³s, ajusta o anterior para NULL
    }

    free(temp);                // Libera o antigo primeiro nÃ³
    return inicio;             // Retorna o novo inÃ­cio
}
```

---

## âœ… ExplicaÃ§Ã£o detalhada:

| Linha                                | O que faz                                          |
|--------------------------------------|----------------------------------------------------|
| `if (!inicio) return NULL;`          | Verifica se a lista estÃ¡ vazia                    |
| `No* temp = inicio;`                 | Guarda o nÃ³ que vai ser removido                  |
| `inicio = inicio->prox;`             | Atualiza o inÃ­cio da lista                        |
| `if (inicio) inicio->ant = NULL;`    | Se houver novo inÃ­cio, ajusta o campo `ant`       |
| `free(temp);`                        | Libera o nÃ³ antigo da memÃ³ria                     |
| `return inicio;`                     | Retorna o novo inÃ­cio da lista                    |

---

## ðŸ§ª Exemplo prÃ¡tico:

Lista antes:
```
[5] â†’ [10] â†’ [20]
```

Chamada:
```c
inicio = removerInicio(inicio);
```

Lista depois:
```
[10] â†’ [20]
```

---

## âœ… ConclusÃ£o:

Essa funÃ§Ã£o **remove o primeiro nÃ³ da lista**, atualizando os ponteiros corretamente para manter a integridade da lista duplamente encadeada.

---


# Lista Duplamente Encadeada em C â€“ FunÃ§Ã£o removerFim()

## âœ… FunÃ§Ã£o removerFim

```c
No* removerFim(No* inicio) {
    if (!inicio) return NULL;  // Lista vazia

    if (!inicio->prox) {
        free(inicio);          // SÃ³ tem um nÃ³
        return NULL;
    }

    No* atual = inicio;
    while (atual->prox) {
        atual = atual->prox;   // Anda atÃ© o Ãºltimo nÃ³
    }

    atual->ant->prox = NULL;   // PenÃºltimo nÃ³ vira o Ãºltimo
    free(atual);               // Libera o antigo Ãºltimo
    return inicio;             // Retorna o inÃ­cio da lista
}
```

---

## âœ… ExplicaÃ§Ã£o detalhada:

| Linha                                | O que faz                                          |
|--------------------------------------|----------------------------------------------------|
| `if (!inicio) return NULL;`          | Verifica se a lista estÃ¡ vazia                    |
| `if (!inicio->prox)`                 | Caso especial: lista com apenas um nÃ³             |
| `No* atual = inicio;`                | ComeÃ§a a percorrer a lista                        |
| `while (atual->prox)`                | AvanÃ§a atÃ© o Ãºltimo nÃ³                            |
| `atual->ant->prox = NULL;`           | O penÃºltimo nÃ³ passa a ser o Ãºltimo               |
| `free(atual);`                       | Libera o antigo Ãºltimo da memÃ³ria                 |
| `return inicio;`                     | Retorna o inÃ­cio da lista                         |

---

## ðŸ§ª Exemplo prÃ¡tico:

Lista antes:
```
[5] â†’ [10] â†’ [20]
```

Chamada:
```c
inicio = removerFim(inicio);
```

Lista depois:
```
[5] â†’ [10]
```

---

## âœ… ConclusÃ£o:

A funÃ§Ã£o **remove o Ãºltimo elemento da lista**, atualizando o ponteiro do penÃºltimo nÃ³ para `NULL`.

----


# Lista Duplamente Encadeada em C â€“ FunÃ§Ãµes removerValor() e buscarNumero()

## ðŸ§© FunÃ§Ã£o removerValor()

```c
No* removerValor(No* inicio, int valor) {
    if (!inicio) return NULL;  // Lista vazia

    No* atual = inicio;

    while (atual && atual->valor != valor) {
        atual = atual->prox;  // Percorre a lista
    }

    if (!atual) return inicio;  // Valor nÃ£o encontrado

    if (!atual->ant && !atual->prox) {
        free(atual);            // Ãšnico nÃ³ da lista
        return NULL;
    }

    if (!atual->ant) {
        inicio = atual->prox;
        inicio->ant = NULL;
    } else if (!atual->prox) {
        atual->ant->prox = NULL;
    } else {
        atual->ant->prox = atual->prox;
        atual->prox->ant = atual->ant;
    }

    free(atual);
    return inicio;
}
```

### âœ… ExplicaÃ§Ã£o passo a passo:

| Linha                                  | O que faz                                   |
|----------------------------------------|-------------------------------------------|
| `if (!inicio) return NULL;`            | Se a lista estiver vazia                   |
| Percorre com `while`                   | Busca o nÃ³ com o valor informado           |
| `if (!atual) return inicio;`           | Se o valor nÃ£o for encontrado              |
| Caso de Ãºnico nÃ³                      | Remove e retorna NULL                      |
| Caso de primeiro nÃ³                  | Ajusta o inÃ­cio da lista                   |
| Caso de Ãºltimo nÃ³                    | Ajusta o penÃºltimo nÃ³                      |
| Caso no meio                         | Ajusta os dois ponteiros (ant e prox)       |
| `free(atual);`                         | Libera o nÃ³ da memÃ³ria                     |

---

## ðŸ§© FunÃ§Ã£o buscarNumero()

```c
int buscarNumero(No* inicio, int valor) {
    No* atual = inicio;

    while (atual) {
        if (atual->valor == valor) {
            return 1;  // Encontrado
        }
        atual = atual->prox;
    }

    return 0;  // NÃ£o encontrado
}
```

### âœ… ExplicaÃ§Ã£o passo a passo:

| Linha                      | O que faz                       |
|----------------------------|---------------------------------|
| `No* atual = inicio;`       | ComeÃ§a a percorrer do inÃ­cio    |
| `while (atual)`            | Anda atÃ© o final da lista       |
| `if (atual->valor == valor)` | Se encontrar o valor, retorna 1 |
| `return 0;`                | Se nÃ£o encontrar, retorna 0     |

---

## ðŸ§ª Exemplo prÃ¡tico de uso:

```c
if (buscarNumero(lista, 10)) {
    printf("Valor 10 encontrado!\n");
}

lista = removerValor(lista, 10);
```

- Primeiro verifica se o nÃºmero existe.
- Depois remove o nÃºmero da lista caso exista.

---

## âœ… ConclusÃ£o:

Essas funÃ§Ãµes sÃ£o usadas para:
- **Procurar valores dentro da lista** (busca)
- **Remover um valor especÃ­fico** da lista mantendo o encadeamento correto.


```c

#include <stdio.h>
#include <stdlib.h>

// Estrutura do nÃ³ da lista duplamente encadeada
typedef struct No {
    int valor;
    struct No* ant;
    struct No* prox;
} No;

// FunÃ§Ã£o para criar um novo nÃ³
No* criarNo(int valor) {
    No* novo = (No*) malloc(sizeof(No));
    novo->valor = valor;
    novo->ant = NULL;
    novo->prox = NULL;
    return novo;
}

// Inserir no inÃ­cio
No* inserirInicio(No* inicio, int valor) {
    No* novo = criarNo(valor);
    if (!inicio) return novo;
    novo->prox = inicio;
    inicio->ant = novo;
    return novo;
}

// Inserir no final
No* inserirFim(No* inicio, int valor) {
    No* novo = criarNo(valor);
    if (!inicio) return novo;
    No* atual = inicio;
    while (atual->prox) {
        atual = atual->prox;
    }
    atual->prox = novo;
    novo->ant = atual;
    return inicio;
}

// Inserir ordenado (crescente)
No* inserirOrdenado(No* inicio, int valor) {
    No* novo = criarNo(valor);
    if (!inicio || valor < inicio->valor) {
        novo->prox = inicio;
        if (inicio) inicio->ant = novo;
        return novo;
    }
    No* atual = inicio;
    while (atual->prox && atual->prox->valor < valor) {
        atual = atual->prox;
    }
    novo->prox = atual->prox;
    if (atual->prox) atual->prox->ant = novo;
    atual->prox = novo;
    novo->ant = atual;
    return inicio;
}

// Remover do inÃ­cio
No* removerInicio(No* inicio) {
    if (!inicio) return NULL;
    No* temp = inicio;
    inicio = inicio->prox;
    if (inicio) inicio->ant = NULL;
    free(temp);
    return inicio;
}

// Remover do final
No* removerFim(No* inicio) {
    if (!inicio) return NULL;
    if (!inicio->prox) {
        free(inicio);
        return NULL;
    }
    No* atual = inicio;
    while (atual->prox) {
        atual = atual->prox;
    }
    atual->ant->prox = NULL;
    free(atual);
    return inicio;
}

// Remover valor especÃ­fico
No* removerValor(No* inicio, int valor) {
    if (!inicio) return NULL;
    No* atual = inicio;
    while (atual && atual->valor != valor) {
        atual = atual->prox;
    }
    if (!atual) return inicio;
    if (!atual->ant && !atual->prox) {
        free(atual);
        return NULL;
    }
    if (!atual->ant) {
        inicio = atual->prox;
        inicio->ant = NULL;
    } else if (!atual->prox) {
        atual->ant->prox = NULL;
    } else {
        atual->ant->prox = atual->prox;
        atual->prox->ant = atual->ant;
    }
    free(atual);
    return inicio;
}

// Buscar nÃºmero
int buscarNumero(No* inicio, int valor) {
    No* atual = inicio;
    while (atual) {
        if (atual->valor == valor) return 1;
        atual = atual->prox;
    }
    return 0;
}

// Imprimir lista
void imprimirLista(No* inicio) {
    No* atual = inicio;
    printf("Lista: ");
    while (atual) {
        printf("%d ", atual->valor);
        atual = atual->prox;
    }
    printf("\n");
}

// FunÃ§Ã£o main para teste
int main() {
    No* lista = NULL;

    lista = inserirOrdenado(lista, 20);
    lista = inserirOrdenado(lista, 10);
    lista = inserirOrdenado(lista, 30);
    imprimirLista(lista);

    lista = removerInicio(lista);
    imprimirLista(lista);

    lista = removerFim(lista);
    imprimirLista(lista);

    lista = inserirInicio(lista, 5);
    imprimirLista(lista);

    lista = inserirFim(lista, 50);
    imprimirLista(lista);

    if (buscarNumero(lista, 50)) {
        printf("Valor 50 encontrado!\n");
    }

    lista = removerValor(lista, 50);
    imprimirLista(lista);

    return 0;
}

```